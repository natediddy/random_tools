#!/usr/bin/env python
#
# Backup/Restore APK's to & from your desktop machine 
# nathanForbes
#

import subprocess
import os
import sys
import shutil
import optparse

from os.path import isfile, isdir

class ExternalError(RuntimeError):
    pass

def command(args, v=True, **kwargs):
    """ Very useful function for creating
        subprocess.Popen objects. Credit Google """
    if v:
        print "Running: ", " ".join(args)
    return subprocess.Popen(args, **kwargs)

home = os.path.expanduser('~')
bdir = os.path.join(home, 'app_backup')
done_zip = "%s-app_backup" % (os.getlogin())

def backup():
    if isdir(bdir):
        shutil.rmtree(bdir)
    os.makedirs(os.path.join(bdir, 'app'))
    os.makedirs(os.path.join(bdir, 'app-private'))
    cmd = ["adb", "pull", "/data/app", os.path.join(bdir, 'app')]
    run = command(cmd, stdout=subprocess.PIPE)
    run.communicate()
    if run.returncode != 0:
        raise ExternalError("Error: ADB pull fail")
    cmd = ["adb", "pull", "/data/app-private", os.path.join(bdir, 'app-private')]
    run2 = command(cmd, stdout=subprocess.PIPE)
    run2.communicate()
    if run2.returncode != 0:
        raise ExternalError("Error: ADB pull fail")
    os.chdir(bdir)

    #TODO: use python's zipfile abilities for this, this kills portability
    cmd = ["zip", "-r", done_zip, "app", "app-private"]
    run3 = command(cmd, stdout=subprocess.PIPE)
    run3.communicate()
    if run3.returncode != 0:
        raise ExternalError("Error: ZIP fail")
    if isfile("%s.zip" % (done_zip)):
        pass
    else:
        raise ExternalError("Error: ZIP fail")
    applist = "     ".join(os.listdir("app"))
    privlist = "     ".join(os.listdir("app-private"))
    sep = os.linesep
    f = open("backup_info.txt", mode="w")
    f.write("Thanx for using AppTool!%s%s"+"="*60+"%s%s"+applist+privlist+"%s%s"+"="*60+"%sAll backed up apps located in %s%s%s" % (sep, sep, sep, sep, sep, sep, sep, os.path.join(bdir, done_zip+'.zip'), sep, sep))
    f.close()
    shutil.rmtree("app")
    shutil.rmtree("app-private")
    print "Done backing up apps. Open %s for details" % os.path.join(bdir, 'backup_info.txt')
    sys.exit()

def restore():
    if not isfile(os.path.join(bdir, done_zip+'.zip')):
        print "Error: %s.zip does not exist. Did you run the backup option?" % done_zip
        sys.exit(1)
    else:
        os.chdir(bdir)
        if isdir("app"):
            shutil.rmtree("app")
        if isdir("app-private"):
            shutil.rmtree("app-private")

        #TODO: use python's zipfile abilities for this, this kills portability
        cmd = ["unzip", "%s.zip" % done_zip]
        run = command(cmd, stdout=subprocess.PIPE)
        run.communicate()
        if run.returncode != 0:
            raise ExternalError("UNZIP fail")
        if isdir(os.path.join(bdir, 'app')):
            for apk in os.listdir(os.path.join(bdir, 'app')):
                if apk is not None:
                    apkname = os.path.basename(apk)
                    cmd = ["adb", "shell", "pm", "install", os.path.join(bdir, 'app', apkname)]
                    run2 = command(cmd, stdin=subprocess.PIPE, stdout=subprocess.PIPE)
                    run2.communicate()
        if isdir(os.path.join(bdir, 'app-private')):
            for apk in os.listdir(os.path.join(bdir, 'app-private')):
                if apk is not None:
                    apkname = os.path.basename(apk)
                    cmd = ["adb", "shell", "pm", "install", os.path.join(bdir, 'app-private', apkname)]
                    run3 = command(cmd, stdin=subprocess.PIPE, stdout=subprocess.PIPE)
                    run3.communicate()
        os.chdir(bdir)
        if isdir("app"):
            shutil.rmtree("app")
        if isdir("app-private"):
            shutil.rmtree("app-private")
    sys.exit()

def devices():
    c = ["adb", "devices"]
    dev = command(c, v=False, stdin=subprocess.PIPE, stdout=subprocess.PIPE)
    x = list(dev.communicate())
    if len(x[0]) < 30:
        return False
    else:
        return True

def main():
    p = optparse.OptionParser(usage='usage: %prog {--backup | --restore}')
    p.add_option('-b', '--backup', dest='backup_apps', action='store_true',
                             help='Backup applications')
    p.add_option('-r', '--restore', dest='restore_apps', action='store_true',
                             help='Restore applications')
    opts, args = p.parse_args()

    if opts.backup_apps and opts.restore_apps:
        p.print_help()
        sys.exit(1)
    if devices():
        if opts.backup_apps:
            return backup()
        if opts.restore_apps:
            return restore()
    else:
        raise ExternalError("Device not plugged in dumbass =p")

if __name__ == '__main__':
    main()
